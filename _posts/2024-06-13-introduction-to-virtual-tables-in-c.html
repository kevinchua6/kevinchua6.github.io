---
layout: post
title: Introduction to Virtual Tables in C++
canonical_url: https://kevinchua67.medium.com/introduction-to-virtual-tables-in-c-540ce4234f00?source=rss-5e9610519e26------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LTgEoWhpaXoVNyow" /><figcaption>Photo by <a href="https://unsplash.com/@fierysnake?utm_source=medium&amp;utm_medium=referral">Nataliya Smirnova</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><h3>What is a vtable?</h3><ul><li><strong>vtable</strong>: A vtable is essentially C++’s implementation of polymorphism. A vtable contains an array of pointers to virtual functions. Each class that has virtual functions (or inherits from a class with virtual functions) has its own vtable.</li><li><strong>vptr</strong>: Each object of such a class contains a pointer (usually referred to as vptr) to the vtable of its class. This pointer allows the object to access the correct function implementations.</li></ul><h3>How it works:</h3><ol><li><strong>Class Definition</strong>:</li></ol><ul><li>When a class with virtual functions is defined, the compiler generates a vtable for that class. The vtable contains pointers to the virtual function implementations.</li></ul><ol><li><strong>Object Instantiation</strong>:</li></ol><ul><li>When an object of that class (or a derived class) is instantiated, the compiler sets the vptr of the object to point to the vtable of the appropriate class.</li></ul><ol><li><strong>Function Call</strong>:</li></ol><ul><li>When a virtual function is called on an object, the call is resolved at runtime by looking up the function pointer in the vtable via the vptr. This allows the program to call the correct function even if the call is made through a base class pointer.</li></ul><h3>Example:</h3><pre>#include &lt;iostream&gt;</pre><pre>class Base {<br>public:<br>    virtual void show() {<br>        std::cout &lt;&lt; &quot;Base show&quot; &lt;&lt; std::endl;<br>    }<br>    virtual void print() {<br>        std::cout &lt;&lt; &quot;Base print&quot; &lt;&lt; std::endl;<br>    }<br>};<br>class Derived : public Base {<br>public:<br>    void show() override {<br>        std::cout &lt;&lt; &quot;Derived show&quot; &lt;&lt; std::endl;<br>    }<br>    void print() override {<br>        std::cout &lt;&lt; &quot;Derived print&quot; &lt;&lt; std::endl;<br>    }<br>};<br>int main() {<br>    Base* b = new Derived();<br>    b-&gt;show();   // Outputs: &quot;Derived show&quot;<br>    b-&gt;print();  // Outputs: &quot;Derived print&quot;<br>    delete b;<br>    return 0;<br>}</pre><h3>What Happens Under the Hood:</h3><ol><li><strong>Vtable Creation</strong>:</li></ol><ul><li>The compiler creates a vtable for Base containing pointers to Base::show and Base::print.</li><li>It also creates a vtable for Derived containing pointers to Derived::show and Derived::print.</li></ul><p><strong>2. Object Initialization</strong>:</p><ul><li>When Derived object is created, its vptr is set to point to the Derived&#39;s vtable.</li></ul><p><strong>3. Virtual Function Call</strong>:</p><ul><li>When b-&gt;show() is called, the program follows b&#39;s vptr to the Derived&#39;s vtable and calls Derived::show.</li><li>Similarly, b-&gt;print() calls Derived::print.</li></ul><h3>Visual Representation:</h3><pre>Base vtable:           Derived vtable:<br>+-----------+          +-----------+<br>| Base::show|          | Derived::show|<br>| Base::print|         | Derived::print|<br>+-----------+          +-----------+</pre><pre>Derived object:<br>+-----------+<br>| vptr ----&gt; | --------&gt; Derived vtable<br>+-----------+</pre><h3>Performance Considerations:</h3><ul><li><strong>Overhead</strong>: The primary overhead involves an extra level of indirection (the vtable lookup) for each virtual function call, and the storage for the vtable and the vptr in each object.</li><li><strong>Impact</strong>: In most applications, this overhead is negligible.</li></ul><h3>Why are vtables Necessary?</h3><p>For classes in C++, non-virtual functions do not have a vtable because they are resolved at compile time, not at runtime. To better understand this, we need to understand the differences between static vs dynamic binding.</p><h3>Static Binding vs. Dynamic Binding</h3><p><strong>Static Binding</strong>:</p><ul><li>Non-virtual functions use static binding, meaning that the function to be called is determined at compile time based on the type of the pointer or reference.</li><li>The compiler knows the exact function to call, so it generates a direct call to the function’s address.</li><li>No extra indirection or lookup is needed.</li></ul><p><strong>Dynamic Binding</strong>:</p><ul><li>Virtual functions use dynamic binding, meaning that the function to be called is determined at runtime based on the actual object type.</li><li>This requires an additional level of indirection through the vtable to resolve the function address.</li></ul><p>I hope you understand the use of vtables now! Thank you!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=540ce4234f00" width="1" height="1" alt="">
