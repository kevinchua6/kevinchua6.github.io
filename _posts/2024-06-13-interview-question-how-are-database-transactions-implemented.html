---
layout: post
title: 'Interview Question: How are Database Transactions Implemented?'
categories: [Database]
canonical_url: https://kevinchua67.medium.com/interview-question-how-are-database-transactions-implemented-f942e47183a4?source=rss-5e9610519e26------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*X9EIqVEubv5X8qgx" /><figcaption>Photo by <a href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral">Christina @ wocintechchat.com</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>I once got asked this question in an interview for a fullstack developer intern position, and I was curious on the best way to answer it, so I did a bit of research afterwards.</p><p>In the context of <a href="https://en.wikipedia.org/wiki/Database">databases</a>, a sequence of database operations that satisfies the ACID properties (which can be perceived as a single logical operation on the data) is called a <em>transaction</em>.</p><p>For example, a transfer of funds from one bank account to another, even involving multiple changes such as debiting one account and crediting another, is a single transaction.</p><p>Transactions are used to ensure data consistency and recoverability in the event of system failures.</p><p>So how are transactions implemented? There are two popular families of techniques: <strong>write-ahead logging</strong> and <strong>shadow paging</strong>.</p><p>For both of them, locks must be acquired on:</p><ul><li>All information to be updated</li><li>All information to be read (depending on the level of isolation)</li></ul><h3>Write-Ahead Logging (WAL)</h3><p>Basically, changes to the database are first recorded in a log before they are applied to the actual data pages.</p><ol><li>Changes to the database are first recorded in a log before they are applied to the actual data pages.</li><li>Before modifying a data page, the system writes a log record that contains the details of the change. This log is written to a durable storage medium (e.g., disk) before the actual data page is updated.</li><li>During system recovery, the log is used to redo or undo transactions to bring the database to a consistent state.</li></ol><ul><li>Concurrency: Allows for concurrent execution of transactions, as the log ensures that changes are recorded before being applied to the database.</li><li>Overhead: Requires additional I/O operations for writing log records, which can introduce some overhead, especially for write-intensive workloads.</li><li>Durability: Provides strong durability guarantees, as the log records are durable before any changes to the data pages are made.</li></ul><h3>Shadow Paging</h3><p>Shadow paging maintains a shadow copy (or snapshot) of the entire database and switches between the old and new versions to implement transactions.</p><ul><li>Principle: Shadow paging maintains a shadow copy (or snapshot) of the entire database and switches between the old and new versions to implement transactions.</li><li>Copy: When a change is made, a new copy of the entire database is created, which becomes the current version, and the old version is retained.</li><li>Recovery: During recovery, the system can simply switch back to the last consistent snapshot (the shadow) to undo any uncommitted transactions.</li><li>Concurrency: Not inherently designed for concurrent execution of transactions, as multiple transactions might need their own shadow copies, which can be space-inefficient.</li><li>Overhead: Creating full copies of the database for each change can be space-intensive and time-consuming.</li><li>Durability: Provides durability when a snapshot is created, but changes might not be durable until a new snapshot is taken.</li></ul><p>An alternative to locking is <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">multiversion concurrency control</a>, in which the database provides each reading transaction the prior, unmodified version of data that is being modified by another active transaction. This allows readers to operate without acquiring locks, i.e., writing transactions do not block reading transactions, and readers do not block writers. Going back to the example, when user A’s transaction requests data that user B is modifying, the database provides A with the version of that data that existed when user B started his transaction. User A gets a consistent view of the database even if other users are changing data. One implementation, namely <a href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot isolation</a>, relaxes the isolation property.</p><h3>Conclusion</h3><p>Choosing between WAL and Shadow Paging depends on the specific requirements and trade-offs of the application:</p><ul><li>WAL is more suitable for systems requiring high concurrency and where durability is crucial, but it incurs some write overhead.</li><li>Shadow Paging can be efficient for read-intensive workloads but might be less suitable for write-intensive systems due to the overhead of creating and maintaining multiple copies of the database.</li></ul><p>In practice, many modern database management systems use a combination of these techniques and other mechanisms to achieve a balance between concurrency, durability, and efficiency.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f942e47183a4" width="1" height="1" alt="">
