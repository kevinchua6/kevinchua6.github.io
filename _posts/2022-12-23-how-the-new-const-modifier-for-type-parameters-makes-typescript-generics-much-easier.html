---
layout: post
title: How the new const modifier for Type Parameters makes Typescript Generics much
  easier
canonical_url: https://kevinchua67.medium.com/how-the-new-const-modifier-for-type-parameters-makes-typescript-generics-much-easier-840890606545?source=rss-5e9610519e26------2
tag:
- generics
- javascript
- programming
- typescript
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hqHGKNJE3oYorUUc" /><figcaption>Photo by <a href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral">Chris Ried</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>Now, after <a href="https://github.com/microsoft/TypeScript/pull/51865">this PR </a>has been merged, it is possible to create generic functions that infer literal expressions. If this seems complicated, let me give an example: by adding a new const modifier for type parameters (inside of &lt;T&gt;), this becomes possible:</p><pre>const identity = &lt;const T&gt;(t: T) =&gt; {<br>    return t;<br>}<br><br>const b = identity({<br>    a: &quot;a&quot;,<br>    b: &quot;b&quot;,<br>    c: &quot;c&quot;<br>});<br><br>// type inferred as:<br>const b: {<br>    readonly a: &quot;a&quot;;<br>    readonly b: &quot;b&quot;;<br>    readonly c: &quot;c&quot;;<br>}</pre><p>Without the const modifier, the compiler infers a more general type:</p><pre>const identity = &lt;const T&gt;(t: T) =&gt; {<br>    return t;<br>}<br><br>const b = identity({<br>    a: &quot;a&quot;,<br>    b: &quot;b&quot;,<br>    c: &quot;c&quot;<br>});<br><br>// type inferred as:<br>const b: {<br>    a: string;<br>    b: string;<br>    c: string;<br>}</pre><p>This can be undesirable when you want to limit the type of values of b to be only certain flags defined in the function input. In other words, as stated in the PR:</p><blockquote>when a literal expression in an argument is contextually typed by a const type parameter, the literal expression is given the most precise type possible.</blockquote><h3>What are literal expressions?</h3><p>When you initialise a variable, they are usually not constrained to the most specific type possible, because it makes sense that the values of the keys can be changed as long as they are string s.</p><pre>const a = {<br>    a: &quot;a&quot;,<br>    b: &quot;b&quot;,<br>    c: &quot;c&quot;<br>};<br><br>// type inferred as:<br>const a: {<br>    a: string;<br>    b: string;<br>    c: string;<br>}</pre><p>The same thing applies to arrays as well — const args = [8,5] is inferred as number[] because the compiler has no idea <em>how many</em> or <em>what kind </em>of elements there are, so it is generally reasonable to infer it to be an array of any size and numerical value.</p><p>When we want the scope of our types to be narrower, we can use literal expressions. Literal expressions can be created by using an <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">as const</a><em> assertion </em>(note that it is not a cast but an assertion, <a href="https://basarat.gitbook.io/typescript/type-system/type-assertion">they are different</a>), which tells the compiler to infer the narrowest type possible — the exact value of the string.</p><pre>const a = {<br>    a: &quot;a&quot;,<br>    b: &quot;b&quot;,<br>    c: &quot;c&quot;<br>} as const;<br><br>// type inferred as:<br>const a: {<br>    readonly a: &quot;a&quot;;<br>    readonly b: &quot;b&quot;;<br>    readonly c: &quot;c&quot;;<br>}</pre><p>The result is somewhat similar to how we would use enums, or union types like type LogLevelStrings = &#39;ERROR&#39; | &#39;WARN&#39; | &#39;INFO&#39; | &#39;DEBUG&#39;;.</p><p>This allows the compiler to verify that not only does the value of a not change, the keys <em>and </em>values would not change as well — in other words, constant.</p><h3>Conclusion</h3><p>After learning about literal expressions, it is easy to see why this new PR is so important. Especially when previously, we had to <a href="https://millsp.github.io/ts-toolbelt/modules/function_narrow.html">force Typescript to do type narrowing</a> in generics using third party tools.</p><p>In many cases for type checking, it is better to have a more constrained type compared to a less constrained one, so any improvements to that is welcome.</p><p>Here’s the Typescript Playground to play with: <a href="https://www.typescriptlang.org/play?jsx=0&amp;ts=5.0.0-dev.20221222#code/MYewdgzgLgBAhjAvDA3gKBp+AuGAiOPAGgywCNc8zjTNhLg80BfAbjTVElgEsATAKZgoPKAE8kMADwAVAHwAKKLhkBKJHNS0YAJwFQArjrAwo7ZmgD0lmF2gx+QkeMlS7seUpXrEm9NaxMPUNjU3YAi05wezJJR2FRMQV0QLhKQhJAinxqTKx6fEYWVVYgA">Typescript Playground</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=840890606545" width="1" height="1" alt="">
