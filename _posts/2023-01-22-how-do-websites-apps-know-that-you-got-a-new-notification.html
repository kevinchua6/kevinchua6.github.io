---
layout: post
title: How do websites/apps know that you got a new Notification?
canonical_url: https://kevinchua67.medium.com/how-do-websites-apps-know-that-you-got-a-new-notification-54f4adbc7a84?source=rss-5e9610519e26------2
tag:
- networking
- web-development
- javascript
- notifications
- websocket
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/700/0*H360Zp1yJoherxqt.jpeg" /></figure><p>How does Gmail know that you got an email without you refreshing the page? Or how does Instagram know instantly that you got a follower request? Generally, there are two approaches: <em>client pull </em>or <em>server push</em>.</p><h3>The Naive Way — Short Polling (Client Pull)</h3><p>Every 10 seconds or so, we send a request (poll) to the server to check for updates. The pros is that server resources are freed almost immediately for each request the moment we send back a response.</p><p>However, this can be expensive for the server as:</p><ul><li>The number of requests are high, generates a lot of traffic</li><li>Updates are not instantaneous</li></ul><p>Thus, client short polling is generally not used in the industry.</p><h3>Long Polling (Client Pull)</h3><p>The idea is that instead of the client constantly polling the server, we want the server to push data to the client as soon as an update happens. However, servers can’t randomly push data to clients as clients don’t listen on an open port and accept incoming connections. So, we need to keep a persistent connection initiated by the client.</p><p>This is based on <a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet</a>, and how it works is that you open a request to the server and wait for its response for a long period of time. The server intentionally does not respond right away, but waits until a notification arrives then responds. In order to keep the connection alive, client and server do need to send an occasional packet to each other.</p><p>There are a few minor problems to note, mainly:</p><ul><li>Timeouts (<em>Connection gets closed by the proxy server if it remains idle for too long</em>)</li><li>Each thread is blocked till a response is made for php/apache (<em>however, any async approach like Node solves this problem</em>)</li></ul><p>Below is a diagram that illustrates how both of these work.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/934/1*tDRSsbqWOOKvrw-aeRfqpA.png" /><figcaption>Short vs Long Polling</figcaption></figure><p>For iOS, this is done through Apple’s servers, so that the phone only has a single persistent connection to Apple’s servers, and then as a developer we proxy notifications through their servers to the client.</p><p>For Android, we can use <a href="https://firebase.google.com/docs/cloud-messaging">Firebase Cloud Messaging</a> as a centralised service at no cost.</p><p>The above models were sufficient for early web applications, because early websites were only displaying static content. But as the web evolved, the need arose to allow servers send data to clients without a client requesting it first. This led to server push technology in the 2000s.</p><p>As the HTTP request-response model was not designed for these use cases, different mechanisms were invented. These mechanisms are WebSockets and server-sent events (SSE).</p><h3>WebSockets (Server Push)</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/621/0*wF4bWez30tWGpeZd.png" /></figure><p>A WebSocket is just a persistent connection between the client and server. It features full-duplex communication channels over a single TCP connection.</p><p>This has lower overhead than half-duplex alternatives like the above mentioned client polling, and facilitates real-time data transfer from and to the server. As such, we don’t need to poll the server whenever we want to receive a real-time response.</p><p>Some libraries like Socket.IO actually have an hierarchy of their own, meaning that it will do client long/short polling when WebSocket fails.</p><h3>Server-Sent Events (Server Push)</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/621/0*ynP0LEn3yoNUd0Al.png" /></figure><p>Unlike WebSockets which has their own protocol, SSEs are transmitted over HTTP and are unidirectional. After an HTTP connection has been established between the server and the client, the server can send automatic updates.</p><p>Think of SSEs as a long-running HTTP request that notifies the client whenever the server has an update. SSEs are designed to be more efficient than long polling, and have features such as automatic reconnection, event IDs, and the ability to send arbitrary events.</p><p>In a nutshell, for when to use each:</p><p><strong>Short Polling</strong>: Never.<br><strong>Long Polling</strong>: Simple to implement, go-to when you don’t need too complex solutions<br><strong>WebSockets</strong>: Mainly for games, not as robust for scenarios like guest wifi networks or firewalled intranets where sockets might fail and only HTTP can get through<br><strong>Server-Sent Events</strong>: Use when you need the efficiency or scalability</p><h3>Resources:</h3><ul><li><a href="https://stackoverflow.com/questions/4642598/short-polling-vs-long-polling-for-real-time-web-applications">Short-polling vs Long-polling for real time web applications?</a></li><li><a href="https://blog.logrocket.com/server-sent-events-vs-websockets/">Server-sent events vs. WebSockets - LogRocket Blog</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=54f4adbc7a84" width="1" height="1" alt="">
