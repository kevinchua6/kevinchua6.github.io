---
layout: post
title: Type interpolation and iterating through properties in TypeScript
categories: [TypeScript]
canonical_url: https://kevinchua67.medium.com/type-interpolation-and-iterating-through-properties-in-typescript-bcf5356f3994?source=rss-5e9610519e26------2
tag:
- typescript
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*df9hE0bbG4gfSHXm" /></figure><h3>Template Literal Types</h3><ul><li>You can concat and interpolate types together like strings</li></ul><pre>type World = &quot;world&quot;;<br><br>type Greeting = `hello ${World}`;</pre><p><a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">Documentation — Template Literal Types</a></p><h3>Mapped Types</h3><ul><li>You can <em>iterate</em> through properties of a type as if the code is being run.</li></ul><pre>type OptionsFlags&lt;Type&gt; = {<br>  [Property in keyof Type]: boolean;<br>};<br><br>// Converts all values of a property to boolean</pre><ul><li>You can even remap properties. Together with Template Literal Types, we can concat strings to each property of an object:</li></ul><pre>type Getters&lt;Type&gt; = {<br>    [Property in keyof Type as `get${Capitalize&lt;string &amp; Property&gt;}`]: () =&gt; Type[Property]<br>};<br><br>interface Person {<br>    name: string;<br>    age: number;<br>    location: string;<br>}<br>type LazyPerson = Getters&lt;Person&gt;;<br>    type LazyPerson = {<br>    getName: () =&gt; string;<br>    getAge: () =&gt; number;<br>    getLocation: () =&gt; string;<br>}</pre><p><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as">Documentation — Mapped Types</a></p><h3>Together with Conditional Types</h3><p>Mapped types work well with other features in this type manipulation section, for example here is <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">a mapped type using a conditional type</a> which returns either a true or false depending on whether an object has the property pii set to the literal true:</p><pre>type ExtractPII&lt;Type&gt; = {<br>  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;<br>};<br><br>type DBFields = {<br>  id: { format: &quot;incrementing&quot; };<br>  name: { type: string; pii: true };<br>};<br><br>type ObjectsNeedingGDPRDeletion = ExtractPII&lt;DBFields&gt;;</pre><h3>Extracting All Methods from a Class</h3><p>Then, we can do magic like this. This allows us to extract all methods from a class:</p><pre>type PickMatching&lt;T, V&gt; =<br>    { [K in keyof T as T[K] extends V ? K : never]: T[K] }<br><br>type ExtractMethods&lt;T&gt; = PickMatching&lt;T, Function&gt;;</pre><p>Basically, we are iterating through all properties of an object, and checking if the values match with V. If so, we return the value, otherwise return never for the value of the key, which is equivalent to omitting the type. The value is set as the value of the original object.</p><h3>References:</h3><p><a href="https://stackoverflow.com/a/70428144">How to create a type that extract all methods from a class in typescript?</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bcf5356f3994" width="1" height="1" alt="">
