---
layout: post
title: Understanding the infer keyword in TypeScript
canonical_url: https://kevinchua67.medium.com/understanding-the-infer-keyword-in-typescript-2b2c5d7ef16f?source=rss-5e9610519e26------2
tag:
- javascript
- typescript
- generics-in-typescript
- conditional-statements
- programming
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hqHGKNJE3oYorUUc" /><figcaption>Photo by <a href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral">Chris Ried</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>The infer keyword was always confusing to me, despite reading up on it multiple times. I’ll try to explain it clearly here.</p><p>Theinfer keyword can only be used in conditional types in order to declaratively introduce a new generic type variable. This is used for many default TypeScript utility types such as Parameters&lt;Type&gt; to get the parameter types of a function and ReturnType&lt;Type&gt;to get the return types of a function.</p><p>For example, the below type checks if T is a function, and returns the return type of that function.</p><pre>type GetReturnType&lt;T&gt; = T extends (...args: never[]) =&gt; infer Return<br>  ? Return<br>  : never;<br><br>type Num = GetReturnType&lt;() =&gt; number&gt;;<br>//   ^ type number<br><br>type Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[]&gt;;<br>//   ^ type boolean[]</pre><p>In other words, we are able to declare the type of the return type of the function without explicitly defining a generic type variable.</p><p>Instead of forcing the return type of the function to be a certain type, we are asking TypeScript to define it as a type variable with the name Return which allows us to use it in other places.</p><h3>What this solves</h3><p>Some of you might think, why not just declare a generic type for the return value then? For example:</p><pre>type GetReturnType&lt;T, Return&gt; = T extends (...args: never[]) =&gt; Return<br>  ? Return<br>  : never;<br><br>type Num = GetReturnType&lt;() =&gt; number, number&gt;;<br>//   ^ type number                     ^ if we don&#39;t fill in this we get an error<br><br>type Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[], boolean[]&gt;;<br>//   ^ type boolean[]                                             ^ if we don&#39;t fill in this we get an error</pre><p>However, this means that you have to define another generic type for the return value, which defeats the purpose of the type definition.</p><h3>What about this?</h3><p>How about not having the infer keyword at all? Why is it necessary?</p><pre>type GetReturnType&lt;T&gt; = T extends (...args: never[]) =&gt; Return<br>  ? Return<br>  : never;<br><br>// error, cannot find name &#39;Return&#39;</pre><p>This doesn’t work because we need to declare our type variables explicitly. TypeScript doesn’t know where the type variable Return comes from.</p><p>Basically, we can think of it as declaring a name for the type, with the type value being the actual type at that location.</p><h3>More Examples</h3><p>I was pretty confused when I first tried to understand this, so here are more examples for understanding.</p><h4>Flatten</h4><p>The below type returns the inner elements if it is an array, otherwise it returns the type itself:</p><pre>type Flatten&lt;T&gt; = T extends Array&lt;infer Item&gt; ? Item : T;<br><br>type Num = Flatten&lt;number[]&gt;<br>//   ^ type number<br><br>type OriginalNumber = Flatten&lt;number&gt;<br>//   ^ type number<br><br>type Bool = Flatten&lt;boolean&gt;<br>//   ^ type boolean</pre><p>It basically declares the elements of an array as a type, and returns it if it exists. If not, it returns the T that does not extend it.</p><h4>GetParameterType</h4><p>The below type gets the parameters of a function type. I took it from<a href="https://github.com/microsoft/TypeScript/pull/26243/files"> the actual </a><a href="https://github.com/microsoft/TypeScript/pull/26243/files">Paramter&lt;T&gt;</a> type implementation from their utility types and made it simpler for better understanding.</p><pre>type GetParameterType&lt;T&gt; = T extends (...args: infer Param) =&gt; any <br>  ? Param   <br>  : never;<br><br>type Num = GetParameterType&lt;(n: number=&gt; number&gt;;<br>//   ^ number<br><br>type Bool = GetParameterType&lt;(n: boolean=&gt; boolean[]&gt;;<br>//   ^ boolean</pre><p>The type of the parameters of the function are declared as the type Param using the infer keyword.</p><h3>Small Things to Note</h3><p>There are certain things to take note which makes sense if you think about it:</p><ol><li>The inferred value can only be used in the true branch, because in the case where T does not extend the type, the inferred value would not exist.</li></ol><pre>type Flatten&lt;T&gt; = T extends Array&lt;infer Item&gt; ? Item : T; // this works<br><br>type Flatten&lt;T&gt; = T extends Array&lt;infer Item&gt; ? T : Item; // cannot find name &#39;Item&#39;.</pre><p>2. infer is always used within the extends clause and not anywhere else.</p><h3>Summary</h3><p>The infer keyword allows us to define types in the context of conditional types so that we can use them elsewhere. It is used extensively in utility types and are very powerful.</p><h3>References</h3><p><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">Documentation - Conditional Types</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2b2c5d7ef16f" width="1" height="1" alt="">
